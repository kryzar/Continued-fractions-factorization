\subsection{Architecture du programme}

\subsubsection{Structure générale}

Notre programme comprend deux étapes principales. La première consiste à générer, 
à partir du développement en fractions continues de $ \sqrt{kN} $, des paires 
$(A, Q)$ avec $Q_n$ friable pour une base de factorisation préalablement déterminée.
On associe à chaque $Q_n$ ainsi produit un vecteur exposant \texttt{mpz\_t exp\_vect}.
Ce vecteur permet de retenir les nombres premiers qui interviennent dans la 
factorisation de $Q_n$ avec une valuation impaire. Dans le but d'augmenter le nombre
de paires $(A,Q) $ acceptées lors de cette étape, nous avons implémenté la \og 
large prime variation \fg{}. Celle-ci permet d'accepter une paire si $Q_n$ se
factorise  grâce aux premiers de la base de factorisation et à un grand facteur
premier supplémentaire. Les fonctions de cette phase de collecte sont rassemblées
dans le fichier \texttt{step\_1.c}. Elles font appel, pour mettre en oeuvre la 
\og large prime variation \fg{}, aux fonctions du fichier \texttt{lp\_var.c}. \\
 
Ces données sont traitées lors de la seconde phase dans l'espoir de trouver un 
facteur non trivial de $N$. Il s'agit de trouver des ensembles valides de paires
$(A, Q)$ par pivot de Gauss sur la matrice dont les lignes sont formées des 
vecteurs exposants. Chaque ensemble valide est à l'origine d'une congruence de 
la forme $A^2 \equiv Q^2$ (mod $N$) permettant potentiellement de trouver un
facteur non trivial de $N$. Les fonctions de cette phase sont regroupées dans 
le fichier \texttt{step\_2.c}. \\

Avant d'effectuer la première étape, il convient de se doter d'une base de 
factorisation. Ceci est permis par une des fonctions de \texttt{init\_algo.c}.
Ces dernières se chargent plus généralement de l'initialisation et du choix par
défaut des paramètres. \\

Finalement, en mettant bout à bout les deux étapes, la fonction 
\texttt{contfract\_factor} du fichier \texttt{fact.c} recherche un facteur
non trivial de $N$ et \texttt{print\_results} affiche les résultats. 

\subsubsection{Entrées et sorties}
Nous avons regroupé dans une structure \texttt{Params} les paramètres d'entrée 
de la fonction de factorisation, à savoir :

\begin{itemize}
    \item \texttt{N} : le nombre à factoriser, supposé produit de deux grands
                       nombres premiers.
    \item \texttt{k} : le coefficient multiplicateur.
    \item \texttt{n\_lim} : le nombre maximal de paires $(A,Q)$ que l'on 
                             s'autorise à calculer. Ce nombre prend en compte
                             toutes les paires produites et non uniquement les
                             paires avec $Q_n$ friable ou produites par la \og 
                             large prime variation \fg{}.
    \item \texttt{s\_fb} : la taille de la base de factorisation. 
    \item \texttt{nb\_want\_AQp} : le nombre désiré de paires $(A,Q)$ avec $Q_n$ 
                                 friable ou produites par la \og large prime 
                                 variation \fg{}.
    \item des booléens indiquant si la \og early abort strategy \fg{} ou la 
          \og large prime variation \fg{} doivent être utilisées et des paramètres
          s'y rapportant.

\end{itemize}

Le programme stocke dans une structure \texttt{Results} un facteur non trivial
de \texttt{N} trouvé (si tel est le cas) ainsi que des données permettant 
l'analyse des performances de la méthode.  

\begin{remarque}
L'efficatité de la méthode dépend du choix des paramètres ci-dessus. Pour avoir
plus de latitude dans les tests, nous les considérons comme des paramètres 
d'entrée du programme. C'est pourquoi notre programme ne s'attèle pas à la
factorisation complète d'un entier, qui aurait nécessité une sous-routine 
déterminant des paramètres optimaux en fonction de la taille de l'entier 
dont on cherche un facteur. 
   
\end{remarque}

\begin{remarque}
Notre programme n'est pas supposé prendre en entrée un nombre admettant un petit
facteur premier (inférieur aux premiers de la base de factorisation par exemple).
En effet, comme il ne teste pas au préalable si \texttt{N} est divisible par de 
petits facteurs, il mettra autant de temps à trouver un petit facteur qu'un
grand facteur.
\end{remarque}


\subsection{Pivot de Gauss et recherche d'un facteur non trivial
            : \texttt{step\_2.c}}

Avant de nous pencher sur les détails de la phase de collecte, regardons 
l'implémentation de la seconde phase, qui aide à comprendre quelles
données nous avons besoin de collecter pendant la première phase et sous 
quelle forme les stocker.

\subsection{Collecte des paires $(A,Q)$ : \texttt{step\_1.c et lp\_var.c}}

Décrivons tout d'abord \NTS{à présent ? choisir l'ordre} la phase de collecte
des données. Elles sont stockées au fur et à mesure de la collecte dans les 
tableaux \texttt{mpz\_t *Ans}, \texttt{mpz\_t *Qns}, \texttt{mpz\_t *exp\_vects}
et \texttt{mpz\_t *hist\_vects}. A un indice correspond un paire $(A,Q)$ donnée.\\ 

\subsubsection{La fonction \texttt{create\_AQ\_pairs}}

Sachant que seules les paires $(A,Q)$ dont on a pu factoriser $Q_n$ nous
intéressent pour la seconde phase, nous avons décidé de ne stocker que celles-ci.
Ce choix a en outre un avantage : étant donné un nombre \texttt{nb\_want\_AQp}
représentant le nombre voulu de telles paires, il est possible d'arrêter le 
développement en fraction continue dès que ce nombre est atteint. Cela évite
d'avoir à stocker toutes les paires $(A,Q)$, pour ensuite sélectionner celles 
qui nous intéressent, en courant le risque d'en avoir trop ou pas assez. \\

Ce choix amène à avoir une grande fonction, en l'occurence 
\texttt{create\_AQ\_pairs}, qui au fur à mesure du développement de $\sqrt{kN}$
en fraction continue, teste si le $Q_n$ qui vient d'être calculé est factorisable.
Si c'est le cas, on crée son vecteur exposant et ajoute les données de la paire
aux tableaux \texttt{Ans}, \texttt{Qns} et \texttt{exp\_vects}. Pour ce faire, la
fonction utilise les sous-routines \texttt{is\_Qn\_factorisable} et 
\texttt{init\_exp\_vect}.

\subsubsection{La \og early abort strategy \fg{}}

La fonction \texttt{is\_Qn\_factorisable} teste si un $Q_n$ est friable 
\footnote {ou presque friable, voir paragraphe suivant.} par divisions successives
avec les premiers de la base de factorisation.  Un moyen d'améliorer les 
performances de la méthode est de décider de ne pas poursuivre les divisions 
successives si après un nombre \texttt{eas\_cut} de divisions la partie non
factorisée de $Q_n$ est trop grande (supérieure à une borne 
\texttt{eas\_bound\_div} proportionnelle à la borne déjà connue $\sqrt{kN}$). 

\subsubsection{La \og large prime variation \fg{}}

Etant donnée une base de factorisation $B = \{ p_1, \cdots, p_m\}$, la \og large
prime variation \fg{} consiste à accepter lors de la collecte, non seulement des 
$Q_n$ $B$-friables mais aussi des $Q_n$ produits d'un entier $B$-friable et d'un
entier $lp_n$ inférieur à $p_m^2$. On dira que $Q_n$ est \emph{presque friable}
et l'on appelera \emph{grand premier (large prime)} le premier $lp_n$ en question. \\

Pour que des $Q_n$ presque friables soient exploitables, il faut qu'ils aient
un grand premier $lp$ en commun. En effet, si on trouve deux entiers presque
friables $Q_{n_1} = X_{n_1}lp $ et $Q_{n_2} =  X_{n_2}lp $, on peut former une
nouvelle paire $(A,Q)$ avec laquelle on peut travailler pour chercher une 
congruence de carrés. \\ 

Remarquons pour cela qu'on a les conguences :
\begin{equation*}
  \left\{
      \begin{aligned}
          A_{n_1 -1}^2 &\equiv (-1)^{n_1} X_{n_1}lp\pmod{N} \\
          A_{n_2 -1}^2 &\equiv (-1)^{n_2} X_{n_2}lp\pmod{N}\\
        \end{aligned}
    \right.
\end{equation*}

En les multipliant, on obtient : 
\[  (A_{n_1 -1} A_{n_2 -1})^2 \equiv 
     \underbrace{(-1)^{n_1 + n_2} X_{n_1} X_{n_2}}_
            {\begin{subarray}{c}\text{associé au vecteur exposant}\\
             v_{B} \big( (-1 )^{n_1} X_{n_1} \big)
             + v_{B} \big( (-1 )^{n_2} X_{n_2} \big) \end{subarray}
             }
    \underbrace{lp^2}_{\text{carré qui ne pose pas problème}}
    \pmod{N}
 \]
  
On forme donc la nouvelle paire $ (A_{n_1-1}A_{n_2 -1} \pmod{N}, Q_{n_1}Q_{n_2}) $
associée au vecteur exposant $v_{B} \big( (-1 )^{n_1} X_{n_1} \big)+
v_{B} \big( (-1 )^{n_2} X_{n_2} \big) $.  Elle sera traitée lors de la 
deuxième phase exactement de la même manière que les paires \og classiques \fg{}.\\

En pratique, pour repérer les paires qui ont le même grand premier, nous
constituons au fur et à mesure de la collecte une liste chainée dont les noeuds
stockent les données d'une paire dont le $Q_n$ est presque friable (les entiers
$Q_n$, $A_{n-1}$, le vecteur exposant et le grand premier associé à $Q_n$). Nous
maintenons cette liste triée par taille des grands premiers. Lorsque que survient
un $Q_n$ presque friable, il est repéré par la fonction
\texttt{is\_Qn\_factorisable} qui fournit également son grand premier $lp$. La 
liste chainée est alors parcourue pour savoir si l'on a déjà rencontré ce $lp$.
Deux cas se présentent alors. Si $lp$ est absent de la liste, on crée à la bonne
place un noeud. Si $lp$ est déjà présent dans la liste, au lieu de rajouter un
noeud, on utilise le noeud possédant ce $lp$ pour obtenir une nouvelle paire
$(A,Q)$ selon la méthode énoncée plus haut et ajoute ses composantes aux tableaux
\texttt{Ans}, \texttt{Qns} et \texttt{exp\_vects}. La fonction
\texttt{insert\_or\_elim\_lp} se charge de cela. \\

évoquer à un moment \texttt{init\_hist\_vects}\\ 



